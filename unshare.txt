UNSHARE(1)                    User Commands                    UNSHARE(1)
NAME         top
       unshare - run program in new namespaces
SYNOPSIS         top
       unshare [options] [program [arguments]]
DESCRIPTION         top
       The unshare command creates new namespaces (as specified by the
       command-line options described below) and then executes the
       specified program. If program is not given, then "${SHELL}" is run
       (default: /bin/sh).

       By default, a new namespace persists only as long as it has member
       processes. A new namespace can be made persistent even when it has
       no member processes by bind mounting /proc/pid/ns/type files to a
       filesystem path. A namespace that has been made persistent in this
       way can subsequently be entered with nsenter(1) even after the
       program terminates (except PID namespaces where a permanently
       running init process is required). Once a persistent namespace is
       no longer needed, it can be unpersisted by using umount(8) to
       remove the bind mount. See the EXAMPLES section for more details.

       unshare since util-linux version 2.36 uses
       /proc/[pid]/ns/pid_for_children and
       /proc/[pid]/ns/time_for_children files for persistent PID and TIME
       namespaces. This change requires Linux kernel 4.17 or newer.

       The following types of namespaces can be created with unshare:

       mount namespace
           Mounting and unmounting filesystems will not affect the rest
           of the system, except for filesystems which are explicitly
           marked as shared (with mount --make-shared; see
           /proc/self/mountinfo or findmnt -o+PROPAGATION for the shared
           flags). For further details, see mount_namespaces(7).

           unshare since util-linux version 2.27 automatically sets
           propagation to private in a new mount namespace to make sure
           that the new namespace is really unshared. It’s possible to
           disable this feature with option --propagation unchanged. Note
           that private is the kernel default.

       UTS namespace
           Setting hostname or domainname will not affect the rest of the
           system. For further details, see uts_namespaces(7).

       IPC namespace
           The process will have an independent namespace for POSIX
           message queues as well as System V message queues, semaphore
           sets and shared memory segments. For further details, see
           ipc_namespaces(7).

       network namespace
           The process will have independent IPv4 and IPv6 stacks, IP
           routing tables, firewall rules, the /proc/net and
           /sys/class/net directory trees, sockets, etc. For further
           details, see network_namespaces(7).

       PID namespace
           Children will have a distinct set of PID-to-process mappings
           from their parent. For further details, see pid_namespaces(7).

       cgroup namespace
           The process will have a virtualized view of /proc/self/cgroup,
           and new cgroup mounts will be rooted at the namespace cgroup
           root. For further details, see cgroup_namespaces(7).

       user namespace
           The process will have a distinct set of UIDs, GIDs and
           capabilities. For further details, see user_namespaces(7).

       time namespace
           The process can have a distinct view of CLOCK_MONOTONIC and/or
           CLOCK_BOOTTIME which can be changed using
           /proc/self/timens_offsets. For further details, see
           time_namespaces(7).
OPTIONS         top
       -i, --ipc[=file]
           Create a new IPC namespace. If file is specified, then the
           namespace is made persistent by creating a bind mount at file.

       -m, --mount[=file]
           Create a new mount namespace. If file is specified, then the
           namespace is made persistent by creating a bind mount at file.
           Note that file must be located on a mount whose propagation
           type is not shared (or an error results). Use the command
           findmnt -o+PROPAGATION when not sure about the current
           setting. See also the examples below.

       -n, --net[=file]
           Create a new network namespace. If file is specified, then the
           namespace is made persistent by creating a bind mount at file.

       -p, --pid[=file]
           Create a new PID namespace. If file is specified, then the
           namespace is made persistent by creating a bind mount at file.
           (Creation of a persistent PID namespace will fail if the
           --fork option is not also specified.)

           See also the --fork and --mount-proc options.

       -u, --uts[=file]
           Create a new UTS namespace. If file is specified, then the
           namespace is made persistent by creating a bind mount at file.

       -U, --user[=file]
           Create a new user namespace. If file is specified, then the
           namespace is made persistent by creating a bind mount at file.

       -C, --cgroup[=file]
           Create a new cgroup namespace. If file is specified, then the
           namespace is made persistent by creating a bind mount at file.

       -T, --time[=file]
           Create a new time namespace. If file is specified, then the
           namespace is made persistent by creating a bind mount at file.
           The --monotonic and --boottime options can be used to specify
           the corresponding offset in the time namespace.

       -f, --fork
           Fork the specified program as a child process of unshare
           rather than running it directly. This is useful when creating
           a new PID namespace. Note that when unshare is waiting for the
           child process, then it ignores SIGINT and SIGTERM and does not
           forward any signals to the child. It is necessary to send
           signals to the child process.

       --keep-caps
           When the --user option is given, ensure that capabilities
           granted in the user namespace are preserved in the child
           process.

       --kill-child[=signame]
           When unshare terminates, have signame be sent to the forked
           child process. Combined with --pid this allows for an easy and
           reliable killing of the entire process tree below unshare. If
           not given, signame defaults to SIGKILL. This option implies
           --fork.

       --mount-proc[=mountpoint]
           Just before running the program, mount the proc filesystem at
           mountpoint (default is /proc). This is useful when creating a
           new PID namespace. It also implies creating a new mount
           namespace since the /proc mount would otherwise mess up
           existing programs on the system. The new proc filesystem is
           explicitly mounted as private (with MS_PRIVATE|MS_REC).

       --mount-binfmt[=mountpoint]
           Just before running the program, mount the binfmt_misc
           filesystem at mountpoint (default is
           /proc/sys/fs/binfmt_misc). It also implies creating a new
           mount namespace since the binfmt_misc mount would otherwise
           mess up existing programs on the system. The new binfmt_misc
           filesystem is explicitly mounted as private (with
           MS_PRIVATE|MS_REC).

       --map-user uid|name
           Run the program only after the current effective user ID has
           been mapped to uid. If this option is specified multiple
           times, the last occurrence takes precedence. This option
           implies --user.

       --map-users inneruid:outeruid:count|auto|subids|all
           Run the program only after the block of user IDs of size count
           beginning at outeruid has been mapped to the block of user IDs
           beginning at inneruid. This mapping is created with
           newuidmap(1) if unshare was run unprivileged. If the range of
           user IDs overlaps with the mapping specified by --map-user,
           then a "hole" will be removed from the mapping. This may
           result in the highest user ID of the mapping not being mapped.
           Use --map-users multiple times to map more than one block of
           user IDs. The special value auto will map the first block of
           user IDs owned by the effective user from /etc/subuid to a
           block starting at user ID 0. The special value subids will
           identity map the same block. The special value all will create
           a pass-through map for every user ID available in the parent
           namespace. This option implies --user.

           Before util-linux version 2.39, this option expected a
           comma-separated argument of the form outeruid,inneruid,count
           but that format is now deprecated for consistency with the
           ordering used in /proc/[pid]/uid_map and the X-mount.idmap
           mount option.

       --map-group gid|name
           Run the program only after the current effective group ID has
           been mapped to gid. If this option is specified multiple
           times, the last occurrence takes precedence. This option
           implies --setgroups=deny and --user.

       --map-groups innergid:outergid:count|auto|subids|all
           Run the program only after the block of group IDs of size
           count beginning at outergid has been mapped to the block of
           group IDs beginning at innergid. This mapping is created with
           newgidmap(1) if unshare was run unprivileged. If the range of
           group IDs overlaps with the mapping specified by --map-group,
           then a "hole" will be removed from the mapping. This may
           result in the highest group ID of the mapping not being
           mapped. Use --map-groups multiple times to map more than one
           block of group IDs. The special value auto will map the first
           block of user IDs owned by the effective user from /etc/subgid
           to a block starting at group ID 0. The special value subids
           will identity map the same block. The special value all will
           create a pass-through map for every group ID available in the
           parent namespace. This option implies --user.

           Before util-linux version 2.39, this option expected a
           comma-separated argument of the form outergid,innergid,count
           but that format is now deprecated for consistency with the
           ordering used in /proc/[pid]/gid_map and the X-mount.idmap
           mount option.

       --map-auto
           Map the first block of user IDs owned by the effective user
           from /etc/subuid to a block starting at user ID 0. In the same
           manner, also map the first block of group IDs owned by the
           effective group from /etc/subgid to a block starting at group
           ID 0. This option is intended to handle the common case where
           the first block of subordinate user and group IDs can map the
           whole user and group ID space. This option is equivalent to
           specifying --map-users=auto and --map-groups=auto.

       --map-subids
           Identity map the first block of user IDs owned by the
           effective user from /etc/subuid. In the same manner, also
           identity map the first block of group IDs owned by the
           effective group from /etc/subgid. This option is equivalent to
           specifying --map-users=subids and --map-groups=subids.

       -r, --map-root-user
           Run the program only after the current effective user and
           group IDs have been mapped to the superuser UID and GID in the
           newly created user namespace. This makes it possible to
           conveniently gain capabilities needed to manage various
           aspects of the newly created namespaces (such as configuring
           interfaces in the network namespace or mounting filesystems in
           the mount namespace) even when run unprivileged. As a mere
           convenience feature, it does not support more sophisticated
           use cases, such as mapping multiple ranges of UIDs and GIDs.
           This option implies --setgroups=deny and --user. This option
           is equivalent to --map-user=0 --map-group=0.

       -c, --map-current-user
           Run the program only after the current effective user and
           group IDs have been mapped to the same UID and GID in the
           newly created user namespace. This option implies
           --setgroups=deny and --user. This option is equivalent to
           --map-user=$(id -ru) --map-group=$(id -rg).

       --propagation private|shared|slave|unchanged
           Recursively set the mount propagation flag in the new mount
           namespace. The default is to set the propagation to private.
           It is possible to disable this feature with the argument
           unchanged. The option is silently ignored when the mount
           namespace (--mount) is not requested.

       --setgroups allow|deny
           Allow or deny the setgroups(2) system call in a user
           namespace.

           To be able to call setgroups(2), the calling process must at
           least have CAP_SETGID. But since Linux 3.19 a further
           restriction applies: the kernel gives permission to call
           setgroups(2) only after the GID map (/proc/pid*/gid_map*) has
           been set. The GID map is writable by root when setgroups(2) is
           enabled (i.e., allow, the default), and the GID map becomes
           writable by unprivileged processes when setgroups(2) is
           permanently disabled (with deny).

       -R, --root dir
           run the command with root directory set to dir.

       -w, --wd dir
           change working directory to dir.

       -S, --setuid uid
           Set the user ID which will be used in the entered namespace.

       -G, --setgid gid
           Set the group ID which will be used in the entered namespace
           and drop supplementary groups.

       -l, --load-interp string
           Load binfmt_misc definition in the namespace (implies
           --mount-binfmt). The string argument is
           :name:type:offset:magic:mask:interpreter:flags. For more
           details about new binary type registration see
           https://www.kernel.org/doc/Documentation/admin-guide/binfmt-misc.rst.
           To manage the F flag in flags with --root parameter,
           binfmt_misc is mounted twice, once before the chroot to load
           the interpreter from the caller filesystem and once after to
           make it available from the chroot userspace.

       --monotonic offset
           Set the offset of CLOCK_MONOTONIC which will be used in the
           entered time namespace. This option requires unsharing a time
           namespace with --time.

       --boottime offset
           Set the offset of CLOCK_BOOTTIME which will be used in the
           entered time namespace. This option requires unsharing a time
           namespace with --time.

       -h, --help
           Display help text and exit.

       -V, --version
           Display version and exit.
NOTES         top
       The proc and sysfs filesystems mounting as root in a user
       namespace have to be restricted so that a less privileged user
       cannot get more access to sensitive files that a more privileged
       user made unavailable. In short the rule for proc and sysfs is as
       close to a bind mount as possible.
EXAMPLES         top
       The following command creates a PID namespace, using --fork to
       ensure that the executed command is performed in a child process
       that (being the first process in the namespace) has PID 1. The
       --mount-proc option ensures that a new mount namespace is also
       simultaneously created and that a new proc(5) filesystem is
       mounted that contains information corresponding to the new PID
       namespace. When the readlink(1) command terminates, the new
       namespaces are automatically torn down.

           # unshare --fork --pid --mount-proc readlink /proc/self
           1

       As an unprivileged user, create a new user namespace where the
       user’s credentials are mapped to the root IDs inside the
       namespace:

           $ id -u; id -g
           1000
           1000
           $ unshare --user --map-root-user \
                   sh -c 'whoami; cat /proc/self/uid_map /proc/self/gid_map'
           root
                    0       1000          1
                    0       1000          1

       As an unprivileged user, create a user namespace where the first
       65536 IDs are all mapped, and the user’s credentials are mapped to
       the root IDs inside the namespace. The map is determined by the
       subordinate IDs assigned in subuid(5) and subgid(5). Demonstrate
       this mapping by creating a file with user ID 1 and group ID 1. For
       brevity, only the user ID mappings are shown:

           $ id -u
           1000
           $ cat /etc/subuid
           1000:100000:65536
           $ unshare --user --map-auto --map-root-user
           # id -u
           0
           # cat /proc/self/uid_map
                    0       1000          1
                    1     100000      65535
           # touch file; chown 1:1 file
           # ls -ln --time-style=+ file
           -rw-r--r-- 1 1 1 0  file
           # exit
           $ ls -ln --time-style=+ file
           -rw-r--r-- 1 100000 100000 0  file

       The first of the following commands creates a new persistent UTS
       namespace and modifies the hostname as seen in that namespace. The
       namespace is then entered with nsenter(1) in order to display the
       modified hostname; this step demonstrates that the UTS namespace
       continues to exist even though the namespace had no member
       processes after the unshare command terminated. The namespace is
       then destroyed by removing the bind mount.

           # touch /root/uts-ns
           # unshare --uts=/root/uts-ns hostname FOO
           # nsenter --uts=/root/uts-ns hostname
           FOO
           # umount /root/uts-ns

       The following commands establish a persistent mount namespace
       referenced by the bind mount /root/namespaces/mnt. In order to
       ensure that the creation of that bind mount succeeds, the parent
       directory (/root/namespaces) is made a bind mount whose
       propagation type is not shared.

           # mount --bind /root/namespaces /root/namespaces
           # mount --make-private /root/namespaces
           # touch /root/namespaces/mnt
           # unshare --mount=/root/namespaces/mnt

       The following commands demonstrate the use of the --kill-child
       option when creating a PID namespace, in order to ensure that when
       unshare is killed, all of the processes within the PID namespace
       are killed.

           # set +m                # Don't print job status messages

           # unshare --pid --fork --mount-proc --kill-child -- \
                  bash --norc -c '(sleep 555 &) && (ps a &) && sleep 999' &
           [1] 53456
           #     PID TTY      STAT   TIME COMMAND
                 1 pts/3    S+     0:00 sleep 999
                 3 pts/3    S+     0:00 sleep 555
                 5 pts/3    R+     0:00 ps a

           # ps h -o 'comm' $! # Show that background job is unshare(1)
           unshare
           # kill $! # Kill unshare(1)
           # pidof sleep

       The pidof(1) command prints no output, because the sleep processes
       have been killed. More precisely, when the sleep process that has
       PID 1 in the namespace (i.e., the namespace’s init process) was
       killed, this caused all other processes in the namespace to be
       killed. By contrast, a similar series of commands where the
       --kill-child option is not used shows that when unshare
       terminates, the processes in the PID namespace are not killed:

           # unshare --pid --fork --mount-proc -- \
                  bash --norc -c '(sleep 555 &) && (ps a &) && sleep 999' &
           [1] 53479
           #     PID TTY      STAT   TIME COMMAND
                 1 pts/3    S+     0:00 sleep 999
                 3 pts/3    S+     0:00 sleep 555
                 5 pts/3    R+     0:00 ps a

           # kill $!
           # pidof sleep
           53482 53480

       The following example demonstrates the creation of a time
       namespace where the boottime clock is set to a point several years
       in the past:

           # uptime -p             # Show uptime in initial time namespace
           up 21 hours, 30 minutes
           # unshare --time --fork --boottime 300000000 uptime -p
           up 9 years, 28 weeks, 1 day, 2 hours, 50 minutes

       The following example execute a chroot into the directory
       /chroot/powerpc/jessie and install the interpreter
       /bin/qemu-ppc-static to execute the powerpc binaries.

           $  unshare --map-root-user --fork --pid --load-interp=":qemu-ppc:M::\\x7fELF\x01\\x02\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x14:\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff:/bin/qemu-ppc-static:OCF" --root=/chroot/powerpc/jessie /bin/bash -l

       The load-interp parameter can be read as following

           qemu-ppc
               is the name of the new file created below
               /proc/sys/fs/binfmt_misc to register the interpreter

           M
               defines the interpreter for a given type of magic number

           \\x7fELF\x01\\x02\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x1
               is the magic number to recognize the file to interpret (in
               this case, the ELF header for PPC32)

           \\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff
               the mask to apply to the magic number

           /bin/qemu-ppc-static
               the interpreter to use with the file

           OCF
               the file is open by the kernel with credential and
               security tokens of the file itself and loaded as soon as
               we register it.
AUTHORS         top
       Mikhail Gusarov <dottedmag@dottedmag.net>, Karel Zak
       <kzak@redhat.com>
SEE ALSO         top
       newuidmap(1), newgidmap(1), clone(2), unshare(2), namespaces(7),
       mount(8)
REPORTING BUGS         top
       For bug reports, use the issue tracker
       <https://github.com/util-linux/util-linux/issues>.
AVAILABILITY         top
       The unshare command is part of the util-linux package which can be
       downloaded from Linux Kernel Archive
       <https://www.kernel.org/pub/linux/utils/util-linux/>. This page is
       part of the util-linux (a random collection of Linux utilities)
       project. Information about the project can be found at 
       ⟨https://www.kernel.org/pub/linux/utils/util-linux/⟩. If you have a
       bug report for this manual page, send it to
       util-linux@vger.kernel.org. This page was obtained from the
       project's upstream Git repository
       ⟨git://git.kernel.org/pub/scm/utils/util-linux/util-linux.git⟩ on
       2025-08-11. (At that time, the date of the most recent commit that
       was found in the repository was 2025-08-05.) If you discover any
       rendering problems in this HTML version of the page, or you
       believe there is a better or more up-to-date source for the page,
       or you have corrections or improvements to the information in this
       COLOPHON (which is not part of the original manual page), send a
       mail to man-pages@man7.org

UNSHARE(1) 사용자 명령어 UNSHARE(1)

NAME

unshare - 새로운 네임스페이스에서 프로그램을 실행한다

SYNOPSIS
unshare [옵션] [program [arguments]]

DESCRIPTION

unshare 명령은 (아래에 설명된 커맨드라인 옵션에 따라) 새로운 네임스페이스들을 생성한 뒤, 지정된 프로그램을 실행한다.
만약 program이 주어지지 않았다면 "${SHELL}"이 실행되며, 기본값은 /bin/sh이다.

기본적으로, 새로 생성된 네임스페이스는 그 안에 프로세스가 존재하는 동안에만 유지된다.
하지만 /proc/pid/ns/type 파일을 파일시스템의 경로에 바인드 마운트(bind mount) 하는 방식으로, 네임스페이스를 영구(persistent)하게 만들 수 있다.
이렇게 영구적으로 만들어진 네임스페이스는, 이후 프로그램이 종료된 뒤에도(단, PID 네임스페이스는 항상 동작 중인 init 프로세스가 필요하므로 예외) nsenter(1)로 다시 진입할 수 있다.
더 이상 필요하지 않은 영구 네임스페이스는 umount(8)으로 해당 바인드 마운트를 제거하여 “영구 아님(비영구)” 상태로 되돌릴 수 있다. 자세한 내용은 EXAMPLES 섹션을 참고하라.

unshare는 util-linux 2.36 버전부터 영구적인 PID 및 TIME 네임스페이스를 위해
/proc/[pid]/ns/pid_for_children 및 /proc/[pid]/ns/time_for_children 파일을 사용한다.
이 변경사항은 Linux 커널 4.17 이상이 필요하다.

unshare로 생성할 수 있는 네임스페이스의 종류는 다음과 같다.

mount namespace (마운트 네임스페이스)

파일시스템을 마운트/언마운트해도, 명시적으로 shared로 설정된 파일시스템(예: mount --make-shared; shared 플래그는 /proc/self/mountinfo 또는 findmnt -o+PROPAGATION에서 확인) 을 제외하면 시스템의 나머지 부분에는 영향을 주지 않는다.
자세한 내용은 mount_namespaces(7)을 보라.

unshare는 util-linux 2.27 버전부터, 새로운 마운트 네임스페이스에서 프로파게이션(propagation)을 자동으로 private으로 설정하여, 해당 네임스페이스가 실제로 “unshared” 상태임을 보장한다.
이 동작은 --propagation unchanged 옵션으로 비활성화할 수 있다. 참고로, private는 커널의 기본 설정값이다.

UTS namespace

hostname이나 domainname을 설정해도 시스템의 나머지 부분에는 영향을 주지 않는다.
자세한 내용은 uts_namespaces(7)을 보라.

IPC namespace

프로세스는 POSIX 메시지 큐, System V 메시지 큐, 세마포어 집합, 공유 메모리 세그먼트에 대해 독립적인 네임스페이스를 갖게 된다.
자세한 내용은 ipc_namespaces(7)을 보라.

network namespace

프로세스는 독립적인 IPv4/IPv6 스택, IP 라우팅 테이블, 방화벽 규칙, /proc/net 및 /sys/class/net 디렉터리 트리, 소켓 등을 갖게 된다.
자세한 내용은 network_namespaces(7)을 보라.

PID namespace

자식 프로세스들은 부모와는 구분된 PID ↔ 프로세스 매핑을 갖게 된다.
자세한 내용은 pid_namespaces(7)을 보라.

cgroup namespace

프로세스는 가상화된 /proc/self/cgroup 뷰를 가지게 되며, 새로운 cgroup 마운트는 해당 네임스페이스의 cgroup 루트에 루트로 마운트된다.
자세한 내용은 cgroup_namespaces(7)을 보라.

user namespace

프로세스는 별도의 UID, GID, capabilities 집합을 갖게 된다.
자세한 내용은 user_namespaces(7)을 보라.

time namespace

프로세스는 CLOCK_MONOTONIC 및/또는 CLOCK_BOOTTIME 에 대해 서로 다른(독립된) 시각을 가질 수 있으며, 이는 /proc/self/timens_offsets를 통해 변경할 수 있다.
자세한 내용은 time_namespaces(7)을 보라.

OPTIONS
-i, --ipc[=file]

새로운 IPC 네임스페이스를 생성한다.
file이 지정되면, 해당 경로에 바인드 마운트를 만들어 네임스페이스를 영구적으로 유지한다.

-m, --mount[=file]

새로운 마운트 네임스페이스를 생성한다.
file이 지정되면, 해당 경로에 바인드 마운트를 만들어 네임스페이스를 영구적으로 유지한다.
단, file은 프로파게이션 타입이 shared가 아닌 마운트 위에 존재해야 하며, 그렇지 않으면 에러가 발생한다.
현재 설정이 확실하지 않다면 findmnt -o+PROPAGATION 명령을 사용하라. 예시는 아래 EXAMPLES 섹션 참고.

-n, --net[=file]

새로운 네트워크 네임스페이스를 생성한다.
file이 지정되면, 해당 경로에 바인드 마운트를 만들어 네임스페이스를 영구적으로 유지한다.

-p, --pid[=file]

새로운 PID 네임스페이스를 생성한다.
file이 지정되면, 해당 경로에 바인드 마운트를 만들어 네임스페이스를 영구적으로 유지한다.
(영구적인 PID 네임스페이스를 생성하려면 반드시 --fork 옵션도 함께 지정해야 한다.)

--fork, --mount-proc 옵션도 참고하라.

-u, --uts[=file]

새로운 UTS 네임스페이스를 생성한다.
file이 지정되면, 해당 경로에 바인드 마운트를 만들어 네임스페이스를 영구적으로 유지한다.

-U, --user[=file]

새로운 user 네임스페이스를 생성한다.
file이 지정되면, 해당 경로에 바인드 마운트를 만들어 네임스페이스를 영구적으로 유지한다.

-C, --cgroup[=file]

새로운 cgroup 네임스페이스를 생성한다.
file이 지정되면, 해당 경로에 바인드 마운트를 만들어 네임스페이스를 영구적으로 유지한다.

-T, --time[=file]

새로운 time 네임스페이스를 생성한다.
file이 지정되면, 해당 경로에 바인드 마운트를 만들어 네임스페이스를 영구적으로 유지한다.
--monotonic, --boottime 옵션은 해당 time 네임스페이스에서 사용할 오프셋을 지정하는 데 사용된다.

-f, --fork

지정한 프로그램을 unshare의 직접 실행이 아니라, 자식 프로세스로 fork 하여 실행한다.
이는 새로운 PID 네임스페이스를 만들 때 유용하다.

unshare가 자식 프로세스를 기다리는 동안에는, SIGINT 및 SIGTERM 시그널을 무시하며 자식에게 시그널을 전달하지 않는다.
따라서 시그널은 자식 프로세스에 직접 보내야 한다.

--keep-caps

--user 옵션이 주어졌을 때, user 네임스페이스에서 부여된 capabilities가 자식 프로세스에 그대로 유지되도록 한다.

--kill-child[=signame]

unshare가 종료될 때, fork된 자식 프로세스에 signame 시그널을 보낸다.
--pid와 함께 사용하면, unshare 아래의 전체 프로세스 트리를 쉽게, 신뢰성 있게 종료(kill)할 수 있다.

지정하지 않으면 기본값은 SIGKILL이며, 이 옵션은 --fork를 암묵적으로 포함한다.

--mount-proc[=mountpoint]

프로그램을 실행하기 직전, mountpoint(기본값: /proc)에 proc 파일시스템을 마운트한다.
이는 새로운 PID 네임스페이스를 생성할 때 유용하다.

또한, 이 동작으로 인해 시스템의 기존 프로그램에 영향을 주지 않도록 하기 위해, 새로운 마운트 네임스페이스 생성도 함께 암묵적으로 수행된다.
새로 마운트되는 proc 파일시스템은 MS_PRIVATE|MS_REC 플래그로 명시적으로 private으로 마운트된다.

--mount-binfmt[=mountpoint]

프로그램을 실행하기 직전에 mountpoint(기본값: /proc/sys/fs/binfmt_misc)에 binfmt_misc 파일시스템을 마운트한다.
이 역시 시스템의 기존 프로그램에 영향을 주지 않도록, 자동으로 새로운 마운트 네임스페이스를 생성한다.
새로 마운트되는 binfmt_misc 파일시스템은 MS_PRIVATE|MS_REC 플래그로 private으로 마운트된다.

--map-user uid|name

현재 유효 사용자 ID가 uid로 매핑된 후에만 프로그램을 실행한다.
이 옵션이 여러 번 지정되면 마지막에 지정된 값이 우선한다.
이 옵션은 --user를 암묵적으로 포함한다.

--map-users inneruid:outeruid:count | auto | subids | all

크기 count인 user ID 범위를, outeruid에서 시작하는 블록 → inneruid에서 시작하는 블록으로 매핑한 뒤에 프로그램을 실행한다.
unshare가 비특권(일반 사용자) 모드로 실행되었다면, 이 매핑은 newuidmap(1)으로 생성된다.

--map-user로 지정된 매핑과 이 범위가 겹치는 경우, 매핑에서 "구멍(hole)"이 제거되어 최상위 user ID가 매핑되지 않을 수 있다.
여러 user ID 블록을 매핑하려면 --map-users를 여러 번 사용한다.

auto: /etc/subuid에서 해당 사용자에게 할당된 첫 번째 user ID 블록을, 네임스페이스 내부의 user ID 0부터 시작하는 블록에 매핑한다.

subids: 같은 블록을 “그대로(identity)” 매핑한다.

all: 상위 네임스페이스에서 사용 가능한 모든 user ID 전체에 대해 그대로 통과(pass-through) 매핑을 생성한다.

이 옵션은 --user를 암묵적으로 포함한다.

util-linux 2.39 버전 이전에는 인수 형식이 outeruid,inneruid,count와 같은 쉼표 구분 형식을 사용했으나,
현재는 /proc/[pid]/uid_map 및 X-mount.idmap 마운트 옵션의 순서와 일관성을 맞추기 위해 더 이상 권장되지 않는다 (deprecated).

--map-group gid|name

현재 유효 그룹 ID를 gid에 매핑한 후에만 프로그램을 실행한다.
이 옵션이 여러 번 지정되면 마지막 지정이 우선한다.
이 옵션은 --setgroups=deny 와 --user를 암묵적으로 포함한다.

--map-groups innergid:outergid:count | auto | subids | all

크기 count인 group ID 범위를, outergid에서 시작하는 블록 → innergid에서 시작하는 블록으로 매핑한 뒤 프로그램을 실행한다.
unshare가 비특권 모드로 실행되었다면, 이 매핑은 newgidmap(1)으로 생성된다.

이 범위가 --map-group으로 지정된 매핑과 겹치면, 매핑에서 "구멍"이 제거되어 최상위 group ID가 매핑되지 않을 수 있다.
여러 group ID 블록을 매핑하려면 --map-groups를 여러 번 사용한다.

auto: /etc/subgid에서 해당 사용자에게 할당된 첫 번째 group ID 블록을, 네임스페이스 내부의 group ID 0부터 시작하는 블록에 매핑한다.

subids: 같은 블록을 그대로(identity) 매핑한다.

all: 상위 네임스페이스에서 사용 가능한 모든 group ID를 그대로 통과 매핑한다.

이 옵션은 --user를 암묵적으로 포함한다.

util-linux 2.39 버전 이전의 outergid,innergid,count 형식은 이제 더 이상 권장되지 않는다.

--map-auto

/etc/subuid에서 현재 유효 사용자가 소유한 첫 번째 user ID 블록을 user ID 0부터 시작하는 블록에 매핑하고,
동일하게 /etc/subgid의 첫 번째 group ID 블록을 group ID 0부터 시작하는 블록에 매핑한다.

일반적으로, 할당된 첫 블록만으로 전체 user/group ID 공간을 매핑할 수 있는 경우를 다루기 위한 편의 기능이며,
--map-users=auto + --map-groups=auto와 동일하다.

--map-subids

/etc/subuid에서 현재 유효 사용자가 소유한 첫 번째 user ID 블록을 동일 값으로(identity) 매핑한다.
마찬가지로 /etc/subgid의 첫 번째 group ID 블록도 동일하게 매핑한다.
이는 --map-users=subids + --map-groups=subids와 동일하다.

-r, --map-root-user

현재 유효 사용자/그룹 ID를, 새로 생성된 user 네임스페이스 내에서 슈퍼유저 UID/GID(0:0) 에 매핑한 뒤에만 프로그램을 실행한다.

이를 통해 비특권 사용자라 하더라도, 새로 생성된 네임스페이스 내부에서
(예: 네트워크 네임스페이스의 인터페이스 설정, 마운트 네임스페이스에서 파일시스템 마운트 등)
각종 관리 작업에 필요한 capabilities를 편리하게 얻을 수 있다.

단, 이는 편의 기능일 뿐이므로, 여러 UID/GID 범위를 복합적으로 매핑하는 고급 사용 사례는 지원하지 않는다.
이 옵션은 --setgroups=deny 및 --user를 암묵적으로 포함하며,
--map-user=0 --map-group=0과 동등하다.

-c, --map-current-user

현재 유효 사용자/그룹 ID를, 새로 생성된 user 네임스페이스에서 동일한 UID/GID 값으로 매핑한 뒤에만 프로그램을 실행한다.
이 옵션은 --setgroups=deny 및 --user를 암묵적으로 포함하며,
--map-user=$(id -ru) --map-group=$(id -rg)와 동등하다.

--propagation private|shared|slave|unchanged

새로운 마운트 네임스페이스에서 마운트 프로파게이션 플래그를 재귀적으로 설정한다.
기본값은 private로 설정하는 것이다.

unchanged를 지정하면 이 기능을 비활성화할 수 있다.
마운트 네임스페이스(--mount)가 요청되지 않은 경우, 이 옵션은 조용히 무시된다.

--setgroups allow|deny

user 네임스페이스에서 setgroups(2) 시스템 콜을 허용할지 말지를 제어한다.

setgroups(2)를 호출하려면 최소한 CAP_SETGID 권한이 필요하다.
하지만 Linux 3.19 이후에는 추가 제약이 있다. 커널은 /proc/pid*/gid_map*에 GID 맵이 설정된 뒤에만 setgroups(2) 호출을 허용한다.

allow (기본값): setgroups(2)가 활성화된 상태이며, 이때 GID 맵은 root가 쓸 수 있다.

deny: setgroups(2)를 영구적으로 비활성화하며, 이 경우 GID 맵은 비특권 프로세스도 쓸 수 있게 된다.

-R, --root dir

루트 디렉터리를 dir로 설정한 상태에서 명령을 실행한다. (chroot 유사)

-w, --wd dir

작업 디렉터리를 dir로 변경한다.

-S, --setuid uid

네임스페이스에 진입했을 때 사용할 user ID를 uid로 설정한다.

-G, --setgid gid

네임스페이스에 진입했을 때 사용할 group ID를 gid로 설정하며, 보조 그룹(supplementary groups)을 제거한다.

-l, --load-interp string

네임스페이스 내에서 binfmt_misc 정의를 로드한다 (--mount-binfmt를 암묵적으로 포함).
string 인수는 다음과 같은 형식이다.

:name:type:offset:magic:mask:interpreter:flags


새 바이너리 타입 등록에 대한 자세한 내용은
https://www.kernel.org/doc/Documentation/admin-guide/binfmt-misc.rst를 참고하라.

--root 파라미터와 함께 F 플래그를 다루기 위해, binfmt_misc는 두 번 마운트된다.
한 번은 chroot 이전에 호출자 파일시스템에서 인터프리터를 로드하기 위해,
또 한 번은 chroot 이후에 그 인터프리터를 chroot 내부에서도 사용할 수 있도록 하기 위해 마운트된다.

--monotonic offset

새 time 네임스페이스에서 사용할 CLOCK_MONOTONIC의 오프셋을 설정한다.
이 옵션은 --time으로 time 네임스페이스를 unshare 해야 한다.

--boottime offset

새 time 네임스페이스에서 사용할 CLOCK_BOOTTIME의 오프셋을 설정한다.
이 옵션 역시 --time과 함께 사용해야 한다.

-h, --help

도움말을 출력하고 종료한다.

-V, --version

버전 정보를 출력하고 종료한다.

NOTES

user 네임스페이스에서 root로 마운트되는 proc 및 sysfs 파일시스템은,
권한이 낮은 사용자가 더 높은 권한의 사용자가 접근 불가하게 만들어 둔 민감한 파일에 접근하지 못하도록 제한해야 한다.

요약하면, proc 및 sysfs에 대한 규칙은 bind 마운트에 최대한 가깝게 맞추는 것이다.

EXAMPLES
PID 네임스페이스와 /proc 마운트를 함께 생성

다음 명령은 PID 네임스페이스를 생성하며, --fork를 사용해 실행되는 명령이 자식 프로세스로 실행되도록 한다.
이 자식 프로세스는 네임스페이스에서 첫 번째 프로세스(PID 1) 가 된다.
--mount-proc 옵션은 동시에 새로운 마운트 네임스페이스를 만들고, 해당 PID 네임스페이스에 대응되는 정보를 담는 새로운 proc(5) 파일시스템을 마운트한다.
readlink(1) 명령이 종료되면 새로 생성된 네임스페이스는 자동으로 정리된다.

# unshare --fork --pid --mount-proc readlink /proc/self
1

비특권 사용자가 root로 매핑된 user 네임스페이스 생성
$ id -u; id -g
1000
1000
$ unshare --user --map-root-user \
      sh -c 'whoami; cat /proc/self/uid_map /proc/self/gid_map'
root
         0       1000          1
         0       1000          1

서브 UID/GID를 사용해 65536개 ID를 매핑하고, 그 안에서 root로 매핑

비특권 사용자가, subuid(5) / subgid(5)에 지정된 65536개 ID 전체를 매핑하고,
자기 계정을 네임스페이스 안에서는 root로 매핑하는 예시이다.
여기서는 user ID 매핑만 예로 든다.

$ id -u
1000
$ cat /etc/subuid
1000:100000:65536
$ unshare --user --map-auto --map-root-user
# id -u
0
# cat /proc/self/uid_map
         0       1000          1
         1     100000      65535
# touch file; chown 1:1 file
# ls -ln --time-style=+ file
-rw-r--r-- 1 1 1 0  file
# exit
$ ls -ln --time-style=+ file
-rw-r--r-- 1 100000 100000 0  file

영구적인 UTS 네임스페이스 생성 및 사용 예

첫 번째 명령은 새로운 영구 UTS 네임스페이스를 만들고, 그 안에서 hostname을 변경한다.
그 후 nsenter(1)로 해당 네임스페이스에 진입해 변경된 hostname을 확인하며,
이는 unshare 명령이 종료된 뒤에도 (네임스페이스 내 멤버 프로세스 없이) 네임스페이스가 계속 존재함을 보여준다.
마지막으로 바인드 마운트를 언마운트하여 네임스페이스를 삭제한다.

# touch /root/uts-ns
# unshare --uts=/root/uts-ns hostname FOO
# nsenter --uts=/root/uts-ns hostname
FOO
# umount /root/uts-ns

영구적인 mount 네임스페이스 생성

다음 명령은 /root/namespaces/mnt 바인드 마운트로 참조되는 영구적인 마운트 네임스페이스를 만든다.
이 바인드 마운트 생성이 성공하도록, 부모 디렉터리(/root/namespaces)를 먼저 바인드 마운트한 뒤,
프로파게이션 타입을 shared가 아닌 값으로 설정한다.

# mount --bind /root/namespaces /root/namespaces
# mount --make-private /root/namespaces
# touch /root/namespaces/mnt
# unshare --mount=/root/namespaces/mnt

--kill-child를 사용한 PID 네임스페이스 전체 종료 예

다음 명령들은 PID 네임스페이스 생성 시 --kill-child 옵션을 사용해,
unshare가 죽을 때 네임스페이스 안의 모든 프로세스도 함께 종료되도록 하는 예시이다.

# set +m    # 잡 상태 메시지를 출력하지 않도록 설정

# unshare --pid --fork --mount-proc --kill-child -- \
       bash --norc -c '(sleep 555 &) && (ps a &) && sleep 999' &
[1] 53456
#     PID TTY      STAT   TIME COMMAND
      1 pts/3    S+     0:00 sleep 999
      3 pts/3    S+     0:00 sleep 555
      5 pts/3    R+     0:00 ps a

# ps h -o 'comm' $!   # 백그라운드 잡이 unshare(1)인지 확인
unshare
# kill $!             # unshare(1) 종료
# pidof sleep


pidof(1)는 아무것도 출력하지 않는다.
이는 sleep 프로세스들이 모두 종료되었음을 의미한다.
좀 더 정확히 말하면, 네임스페이스에서 PID 1(즉, 해당 네임스페이스의 init 프로세스)이었던 sleep 프로세스가 죽으면서, 그 네임스페이스의 나머지 프로세스들도 모두 종료된 것이다.

반대로, --kill-child 없이 비슷한 예를 실행하면, unshare가 종료되더라도 PID 네임스페이스 안의 프로세스는 계속 남아 있음을 볼 수 있다.

# unshare --pid --fork --mount-proc -- \
       bash --norc -c '(sleep 555 &) && (ps a &) && sleep 999' &
[1] 53479
#     PID TTY      STAT   TIME COMMAND
      1 pts/3    S+     0:00 sleep 999
      3 pts/3    S+     0:00 sleep 555
      5 pts/3    R+     0:00 ps a

# kill $!
# pidof sleep
53482 53480

time 네임스페이스에서 부팅 시간을 과거로 설정하는 예

다음 예시는 boottime clock이 몇 년 전으로 설정된 time 네임스페이스를 만드는 예이다.

# uptime -p    # 기존 time 네임스페이스의 uptime
up 21 hours, 30 minutes
# unshare --time --fork --boottime 300000000 uptime -p
up 9 years, 28 weeks, 1 day, 2 hours, 50 minutes

다른 아키텍처용 chroot 환경 + qemu 인터프리터 설정 예

다음 예시는 /chroot/powerpc/jessie로 chroot한 뒤,
PowerPC 바이너리를 실행하기 위한 인터프리터 /bin/qemu-ppc-static을 설치하는 예이다.

$ unshare --map-root-user --fork --pid \
  --load-interp=":qemu-ppc:M::\\x7fELF\x01\\x02\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x14:\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff:/bin/qemu-ppc-static:OCF" \
  --root=/chroot/powerpc/jessie /bin/bash -l


load-interp 파라미터는 다음과 같이 해석할 수 있다.

qemu-ppc
/proc/sys/fs/binfmt_misc 아래에 생성되는 새 파일 이름으로, 인터프리터를 등록하는 데 사용된다.

M
특정 매직 넘버 타입에 대한 인터프리터를 정의함을 의미한다.

\\x7fELF\x01\\x02\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x1
인터프리트할 파일을 인식하기 위한 매직 넘버(여기서는 PPC32용 ELF 헤더)

\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff
매직 넘버에 적용할 마스크 값

/bin/qemu-ppc-static
해당 파일을 실행할 때 사용할 인터프리터

OCF
커널이 파일을 그 파일 자체의 credential 및 security 토큰으로 열고, 등록 즉시 로드하도록 하는 플래그 집합

AUTHORS

Mikhail Gusarov <dottedmag@dottedmag.net>,
Karel Zak <kzak@redhat.com>

SEE ALSO

newuidmap(1), newgidmap(1), clone(2), unshare(2), namespaces(7), mount(8)

REPORTING BUGS

버그 리포트는 다음 이슈 트래커를 사용하라:
https://github.com/util-linux/util-linux/issues

AVAILABILITY

unshare 명령은 util-linux 패키지의 일부이며,
Linux Kernel Archive에서 다운로드할 수 있다:
https://www.kernel.org/pub/linux/utils/util-linux/

이 페이지는 util-linux 프로젝트(각종 Linux 유틸리티 모음)의 일부이다.
프로젝트 정보는 다음에서 확인할 수 있다:
https://www.kernel.org/pub/linux/utils/util-linux/

이 매뉴얼 페이지에 대한 버그 리포트는
util-linux@vger.kernel.org로 보내면 된다.

이 페이지는 상류 Git 저장소에서 가져온 것이다:
git://git.kernel.org/pub/scm/utils/util-linux/util-linux.git (2025-08-11 기준, 해당 저장소에서 가장 최근 커밋 날짜는 2025-08-05였다.)

이 HTML 버전에서 렌더링 문제를 발견했거나, 더 좋은/최신 소스가 있다고 생각되거나,
여기에 포함된 COLOPHON 정보(원래 매뉴얼 페이지의 일부가 아님)에 대한 수정/개선이 있다면
man-pages@man7.org로 메일을 보내면 된다.